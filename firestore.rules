rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is admin or super_admin
    function isAdmin() {
      let userRole = request.auth != null ? get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role : null;
      return userRole == 'admin' || userRole == 'super_admin';
    }
    
    // Helper function to check if user is owner
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }
    
    // Users collection
    match /users/{uid} {
      // Users can read their own user doc, admins can read all
      allow read: if isOwner(uid) || isAdmin();
      
      // Users can create their own user doc (during registration)
      allow create: if isOwner(uid) && 
                      request.resource.data.keys().hasAll(['displayName', 'phoneNumber', 'role', 'kycStatus', 'vipDepositWaived', 'createdAt']) &&
                      request.resource.data.role == 'user' &&
                      request.resource.data.vipDepositWaived == false &&
                      request.resource.data.kycStatus == 'not_submitted';
      
      // Users can update only their own doc, with restrictions
      allow update: if isOwner(uid) && (
        // User can update displayName, kycStatus (to pending only on submit), kycSubmittedAt, FCM fields
        (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'vipDepositWaived', 'strikeCount', 'kycRejectionReason']) ||
         isAdmin()) &&
        // User can only set kycStatus to 'pending' on submit, not to approved/rejected
        (!('kycStatus' in request.resource.data.diff(resource.data).affectedKeys()) ||
         request.resource.data.kycStatus == 'pending' ||
         isAdmin())
      ) ||
      // User can update only FCM token fields on their own doc
      (isOwner(uid) &&
       request.resource.data.diff(resource.data).affectedKeys()
         .hasOnly(['fcmToken', 'platform', 'tokenUpdatedAt'])) ||
      // Admin can assign role (user / admin / super_admin) to any user
      (isAdmin() &&
       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['role']));
    }
    
    // KYC Requests collection — one doc per user (doc id = uid). Only one active request at a time.
    match /kycRequests/{uid} {
      // Users can read their own KYC request
      allow read: if isOwner(uid) || isAdmin();
      
      // User can create their KYC request (no existing doc or overwriting not-submitted)
      allow create: if isOwner(uid) && (
        !('status' in request.resource.data) ||
        request.resource.data.status == 'pending'
      ) &&
      (!('reviewedBy' in request.resource.data) &&
       !('reviewedAt' in request.resource.data) &&
       !('rejectionReason' in request.resource.data));
      
      // User can update only when current status is NOT pending (e.g. rejected — resubmit). Prevents duplicate/overwrite while under review.
      allow update: if isOwner(uid) &&
                      resource.data.status != 'pending' &&
                      (!('status' in request.resource.data) || request.resource.data.status == 'pending') &&
                      (!('reviewedBy' in request.resource.data) &&
                       !('reviewedAt' in request.resource.data) &&
                       !('rejectionReason' in request.resource.data));
      
      // Admin can review (approve/reject) and write reviewedBy/reviewedAt/rejectionReason
      allow update: if isAdmin() && (
        // Admin can change status, write reviewedBy, reviewedAt, rejectionReason
        'status' in request.resource.data.diff(resource.data).affectedKeys() ||
        'reviewedBy' in request.resource.data.diff(resource.data).affectedKeys() ||
        'reviewedAt' in request.resource.data.diff(resource.data).affectedKeys() ||
        'rejectionReason' in request.resource.data.diff(resource.data).affectedKeys()
      );
    }
    
    // Wallets: availableDeposit and deposit refs (depositPaymentIntentId, etc.) are backend-only.
    match /wallets/{uid} {
      allow read: if isOwner(uid) || isAdmin();
      
      // Owner can create their own wallet once with zero balances (lockedDeposit optional for backward compat)
      allow create: if isOwner(uid) &&
                      request.resource.data.keys().hasAll(['availableDeposit', 'reservedDeposit', 'depositStatus', 'updatedAt']) &&
                      request.resource.data.availableDeposit == 0 &&
                      request.resource.data.reservedDeposit == 0 &&
                      request.resource.data.depositStatus == 'none';
      allow delete: if false;
      // Client may update only reservedDeposit, depositStatus, updatedAt. availableDeposit and deposit refs (depositPaymentIntentId, depositAmount, depositCreatedAt, depositRefs) are backend-only.
      allow update: if isOwner(uid) &&
                      request.resource.data.diff(resource.data).affectedKeys()
                        .hasOnly(['reservedDeposit', 'depositStatus', 'updatedAt']);
    }
    
    // Auctions collection — public read required for guest browsing (Home/Explore/Category lists)
    match /auctions/{auctionId} {
      allow read: if true;

      // Create: Only seller can create DRAFT auctions, and sellerId must match auth.uid
      allow create: if request.auth != null &&
                      request.resource.data.sellerId == request.auth.uid &&
                      request.resource.data.ownerUid == request.auth.uid &&
                      request.resource.data.state == 'DRAFT' &&
                      // Validate images array if present
                      (!('images' in request.resource.data) ||
                       (request.resource.data.images is list &&
                        request.resource.data.images.size() <= 6));
      
      // Update: Complex rules
      allow update: if request.auth != null && (
        // Seller can update their own DRAFT auctions (but not state transitions)
        (resource.data.sellerId == request.auth.uid && 
         (resource.data.ownerUid == request.auth.uid || resource.data.ownerUid == null) &&
         resource.data.state == 'DRAFT' &&
         request.resource.data.state == 'DRAFT' &&
         request.resource.data.sellerId == resource.data.sellerId &&
         request.resource.data.state == 'DRAFT' &&
         // If updating images, validate array (exactly one primary validated in service layer)
         (!('images' in request.resource.data.diff(resource.data).affectedKeys()) ||
          (request.resource.data.images is list &&
           request.resource.data.images.size() <= 6))) ||
        // Bidder can update ACTIVE auction bid fields only (currentPrice, currentWinnerId, bidCount, endsAt)
        (resource.data.state == 'ACTIVE' &&
         request.resource.data.state == 'ACTIVE' &&
         request.resource.data.diff(resource.data).affectedKeys()
           .hasOnly(['currentPrice', 'currentWinnerId', 'bidCount', 'endsAt'])) ||
        // Admin can approve/activate and change state
        isAdmin() ||
        // Seller can update delivery confirmation
        (resource.data.sellerId == request.auth.uid && 
         resource.data.state == 'ENDED' &&
         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['sellerConfirmedDelivery']) ||
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['sellerConfirmedDelivery', 'sellerConfirmedAt']))) ||
        // Winner can update purchase confirmation and delivery confirmation (deliveryStatus, buyerConfirmedAt)
        (resource.data.currentWinnerId == request.auth.uid && 
         resource.data.state == 'ENDED' &&
         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['buyerConfirmedPurchase', 'purchaseConfirmedAt']) ||
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['buyerConfirmedDelivery']) ||
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['buyerConfirmedDelivery', 'buyerConfirmedAt', 'deliveryStatus', 'deliveryConfirmedAt']) ||
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['buyerConfirmedPurchase', 'purchaseConfirmedAt', 'buyerConfirmedDelivery']))) ||
        // Admin can force release contact
        (isAdmin() && 
         resource.data.state == 'ENDED' &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['winnerContactReleased']))
      );
      
      // Delete: seller can delete their own DRAFT or PENDING_APPROVAL auction only
      allow delete: if request.auth != null &&
                      resource.data.sellerId == request.auth.uid &&
                      (resource.data.ownerUid == request.auth.uid || !('ownerUid' in resource.data)) &&
                      (resource.data.state == 'DRAFT' || resource.data.state == 'PENDING_APPROVAL');
      
      // Bids subcollection
      match /bids/{bidId} {
        // Public read for bid history display; create requires auth
        allow read: if true;

        // Create bid: strict rules
        allow create: if request.auth != null &&
                        request.auth.uid == request.resource.data.bidderId &&
                        // Auction must be ACTIVE
                        get(/databases/$(database)/documents/auctions/$(auctionId)).data.state == 'ACTIVE' &&
                        // Bidder cannot be seller
                        get(/databases/$(database)/documents/auctions/$(auctionId)).data.sellerId != request.auth.uid &&
                        // Amount must be >= currentPrice + minIncrement
                        request.resource.data.amount >= 
                          (get(/databases/$(database)/documents/auctions/$(auctionId)).data.currentPrice + 
                           get(/databases/$(database)/documents/auctions/$(auctionId)).data.minIncrement);
        
        // No updates or deletes
        allow update, delete: if false;
      }
    }
    
    // AdminSettings collection
    match /adminSettings/{docId} {
      // Read allowed for authenticated users
      allow read: if request.auth != null;
      
      // Write only by admins
      allow write: if isAdmin();
    }
    
    // Deposits collection
    match /deposits/{uid} {
      // Users can read their own deposit doc; admins can read all
      allow read: if isOwner(uid) || isAdmin();
      
      // Writes controlled - MVP allows some controlled fields
      allow create, update: if isOwner(uid) && 
                              // Only allow status and lastActionAt updates
                              (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'lastActionAt', 'amount', 'note']) ||
                               isAdmin());
    }
    
    // Reservations collection
    match /reservations/{uid}/active/{auctionId} {
      // Users can read their own reservations
      allow read: if isOwner(uid);
      
      // Create/update reservation allowed during bidding (server logic)
      // For MVP, allow controlled writes
      allow write: if isOwner(uid) && 
                     request.resource.data.keys().hasAll(['requiredDeposit', 'lastBidAmount', 'updatedAt']) ||
                     isAdmin();
      
      // Delete allowed (release reservation)
      allow delete: if isOwner(uid) || isAdmin();
    }
    
    // Contracts collection
    match /contracts/{auctionId} {
      // Seller and buyer can read their contract
      allow read: if request.auth != null && 
                    (resource.data.sellerId == request.auth.uid || 
                     resource.data.buyerId == request.auth.uid ||
                     isAdmin());
      
      // Create allowed by server/admin only
      allow create: if isAdmin();
      
      // Update: allow controlled field updates (terms acceptance)
      allow update: if request.auth != null && (
        // Seller can accept their terms
        (resource.data.sellerId == request.auth.uid && 
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['termsAcceptedSeller', 'acceptedAtSeller'])) ||
        // Buyer can accept their terms
        (resource.data.buyerId == request.auth.uid && 
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['termsAcceptedBuyer', 'acceptedAtBuyer'])) ||
        // Admin can update anything
        isAdmin()
      );
    }
    
    // Payments collection - writable by backend only (via Cloud Functions)
    match /payments/{paymentId} {
      // Users can read their own payments
      allow read: if isOwner(resource.data.uid);
      
      // Writes only by backend (Cloud Functions) - block all client writes
      allow write: if false;
    }
    
    // Platform revenue (admin only)
    match /platformRevenue/{docId} {
      allow read: if isAdmin();
      allow write: if false;
    }
    
    // Support chat (legacy): supportChats/{userId}/messages — kept for backward compatibility
    match /supportChats/{userId} {
      allow read, write: if isOwner(userId) || isAdmin();
      match /messages/{messageId} {
        allow read, write: if isOwner(userId) || isAdmin();
      }
    }

    // Support threads: support_threads/{threadId} - multi-ticket per user
    // threadId = uid (legacy) or uid_T{timestamp} (new tickets after closure)
    // User owns if threadId==uid or resource.data.userId==uid
    function isSupportThreadOwner(threadId) {
      return request.auth != null && (
        request.auth.uid == threadId ||
        (resource != null && resource.data.get('userId', '') == request.auth.uid)
      );
    }
    // User can create a thread only when the document's userId equals their uid (e.g. .add() with userId).
    function canCreateSupportThread(threadId) {
      return request.auth != null
        && 'userId' in request.resource.data
        && request.resource.data.userId == request.auth.uid;
    }
    function ownsSupportThread(threadId) {
      let thread = get(/databases/$(database)/documents/support_threads/$(threadId));
      return request.auth != null && (
        request.auth.uid == threadId ||
        thread.data.get('userId', '') == request.auth.uid
      );
    }
    match /support_threads/{threadId} {
      allow read: if isSupportThreadOwner(threadId) || isAdmin();
      allow create: if canCreateSupportThread(threadId) || isAdmin();
      allow update: if isSupportThreadOwner(threadId) || isAdmin();
      allow delete: if isAdmin();
      match /messages/{messageId} {
        allow read: if ownsSupportThread(threadId) || isAdmin();
        allow create: if (ownsSupportThread(threadId) || isAdmin()) &&
          (isAdmin() || get(/databases/$(database)/documents/support_threads/$(threadId)).data.get('status', 'open') != 'closed');
        allow update, delete: if isAdmin();
      }
    }
    
    // Support tickets (contact form submissions)
    match /supportTickets/{ticketId} {
      // Authenticated users can create; admins can read all
      allow create: if request.auth != null;
      allow read: if isAdmin();
      allow update, delete: if isAdmin();
    }
    
    // FAQ (read by all authenticated)
    match /faq/{faqId} {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }
    
    // Content (terms, etc.) - read by all authenticated
    match /content/{docId} {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }
    
    // Ads (partner banners) - public read, write by admin
    match /ads/{adId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
    }
    
    // Ad requests (partners requesting advertising)
    match /adRequests/{requestId} {
      allow create: if request.auth != null;
      allow read, update, delete: if isAdmin();
    }
  }
}
